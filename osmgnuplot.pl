#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Euclid qw(:defer);
use feature ':5.10';

use LWP::UserAgent;
use Digest::MD5 qw(md5);
use PDL;
use PDL::Fit::Linfit;

my @ARGV_original = @ARGV;
my @thiscmd_tokens = split('/',$0);
my $thiscmd =  $thiscmd_tokens[-1];
Getopt::Euclid->process_args(\@ARGV);



my $pi = 3.14159265359;


my $userAgent = LWP::UserAgent->new;




my $center_lat = $ARGV{'--center'}{lat};
my $center_lon = $ARGV{'--center'}{lon};
my $zoom       = $ARGV{'--zoom'};

# I want radius in meters
my ($rad,$unit) = $ARGV{'--rad'} =~ /([0-9\.]+)(.*?)$/;
if   ($unit =~ /mile/) { $rad *= 5280 * 12 * 2.54 / 100; }
elsif($unit =~ /km/ )  { $rad *= 1000; }

my $Rearth = 6371000.0; # meters


my @lat = ($center_lat - $rad/$Rearth * 180.0/$pi,
           $center_lat + $rad/$Rearth * 180.0/$pi );

my @lon = ($center_lon - $rad/$Rearth * 180.0/$pi / cos($center_lat * $pi/180.0),
           $center_lon + $rad/$Rearth * 180.0/$pi / cos($center_lat * $pi/180.0) );

my @tilex = map { lon2tilex($_, $zoom ) } @lon;
my @tiley = map { lat2tiley($_, $zoom ) } @lat;

my @montage_tile_list;
for my $y ($tiley[1]..$tiley[0]) # vertical tiles are ordered backwards because
                                 # that's how the mapping function works
{
    for my $x ($tilex[0]..$tilex[1])
    {
        my $path = tile2path($x, $y, $zoom);
        my $tileurl = "http://tile.openstreetmap.org/$path";
        my $filename = "tile_${x}_${y}_${zoom}.png";


        my @get_args = (":content_file" => $filename);

        if( -r $filename )
        {
            # a local file exists. use it if possible

            # compute the checksum of the local file
            local  $/ = undef;
            open TILE, $filename;
            my $md5_cache = join('', unpack('H*', md5(<TILE>)));
            close TILE;

            # tells server to only send data if needed
            push @get_args, ('if-none-match' => "\"$md5_cache\"" );
        }

        say STDERR "Downloading $tileurl";
        $userAgent->get($tileurl, @get_args)
          or die "Error downloading '$tileurl'";

        push @montage_tile_list, $filename;
    }
}

my $Ntiles_width  = $tilex[1] - $tilex[0] + 1;
my $Ntiles_height = $tiley[1] - $tiley[0] + 1;

my $montage_filename = "montage_${center_lat}_${center_lon}_$ARGV{'--rad'}_$zoom.png";
system("montage @montage_tile_list -tile ${Ntiles_width}x${Ntiles_height} -geometry +0+0 $montage_filename") == 0
  or die "Error running montage: $@";



# I now generate a gnuplot scrript. Here I require dx,dy,centerx,centery to
# properly scale, position the montage

# derived from the source of Geo::OSM::Tiles
my $dx = 360 * 2**(-$zoom) / 256;
my $centerx = ($tilex[0]*256 + $tilex[1]*256 + 255) / 2;
$centerx = $centerx/256 * 2**(-$zoom) * 360 - 180;

# This is (clearly) non-linear, but for small spans of latitude should be linear
# enough. I sample this function through my range, apply linear least squares to
# fit a line to it, and get dy and centery from this line
my $lat_fit = zeros(10)->xlinvals(0, $lat[1]-$lat[0]);
my $tile_fit= pdl( map { tile_from_lat($_,$lat[0],$zoom) } $lat_fit->list );
my ($fit, $coeffs) = linfit1d($lat_fit, $tile_fit, PDL::cat( $lat_fit->ones,
                                                             $lat_fit));
my @c = $coeffs->list;

# I now have tile ~ $c[0] + (lat - $lat[0])*$c[1];

my $centery = ($tiley[0] + $tiley[1] + 255/256) / 2; # tile
$centery = ($centery - $c[0]) / $c[1] + $lat[0];

# c1 is tiles/deg. I want dy = (1/c1) (deg/tiles) / 256 (px/tile)
my $dy = -1/($c[1]*256); # negative because gnuplot inverts y by
                         # default, so the negative slope this thing has
                         # is not needed



my $gnuplot_script = <<EOF;
# Generated by osmgnuplot.pl from
#   https://github.com/dkogan/osmgnuplot
#
# Command used:
#   $thiscmd @ARGV_original

attenuation = 1.5

set autoscale noextend

set size ratio -1./cos($center_lat * pi/180.0)
plot "$montage_filename" binary filetype=png dx=$dx dy=$dy center=($centerx,$centery) using (\$1/attenuation):(\$2/attenuation):(\$3/attenuation) with rgbimage notitle
EOF

my $gpfilename = $montage_filename;
$gpfilename =~ s/png$/gp/;

open GP, '>', $gpfilename;
print GP $gnuplot_script;
close GP;

say "Done! Gnuplot script '$gpfilename' uses the image '$montage_filename'";









# This is derived from Geo::OSM::Tiles
sub tile_from_lat
{
    # input is in degrees, relative to $lat[0]
    # output is floating-point tile index
    #
    # This is done to keep the x variables near 0 to make the slope estimate
    # accurate

    my ($lat_here, $lat0, $zoom) = @_;

    $lat_here += $lat0;
    $lat_here *= $pi/180.0;

    return (1 - log(tan($lat_here) + 1.0/cos($lat_here))/$pi)/2 * 2**$zoom;
}



# These come directly from Geo::OSM::Tiles. I needed my own tile_from_lat()
# anyway, so I may as well copy these here to not require the dependency.
#
# These are Copyright (C) 2008-2010 by Rolf Krahl, distributed under the same
# terms as Perl itself, either Perl version 5.8.8 or, at your option, any later
# version of Perl 5 you may have available.
sub lon2tilex
{
    my ($lon, $zoom) = @_;
    return int( ($lon+180)/360 * 2**$zoom );
}
sub lat2tiley
{
    my ($lat, $zoom) = @_;
    my $lata = $lat*$pi/180;

    my $s = sin($lata);
    my $c = cos($lata);
    return int( (1 - log( ($s + 1.)/$c )/$pi)/2 * 2**$zoom );
}
sub tile2path
{
    my ($tilex, $tiley, $zoom) = @_;
    return "$zoom/$tilex/$tiley.png";
}


__END__

=head1 NAME

osmgnuplot.pl - Download OSM tiles, and make a gnuplot script to render them

=head1 SYNOPSIS

 $ osmgnuplot.pl --center 34.094719,-118.235779 --rad 300m --zoom 16
 Downloading http://tile.openstreetmap.org/16/11243/26158.png
 Downloading http://tile.openstreetmap.org/16/11244/26158.png
 Downloading http://tile.openstreetmap.org/16/11243/26159.png
 Downloading http://tile.openstreetmap.org/16/11244/26159.png
 Done! Gnuplot script 'montage_34.094719_-118.235779_300m_16.gp' uses the image 'montage_34.094719_-118.235779_300m_16.png'

 $ gnuplot -persist montage_34.094719_-118.235779_300m_16.gp
 [a gnuplot window pops up, showing OSM tiles]

=head1 DESCRIPTION

This script downloads OSM tiles, glues them together into a single image, and
generates a gnuplot script to render this image, aligned correctly to its
latitude, longitude. While this in itself is not useful, the gnuplot script can
be expanded to plot other things on top of the map, to make it easy to visualize
geospatial data. Example plots appear here:

L<http://notes.secretsauce.net/notes/2015/08/16_least-convenient-location-in-los-angeles-from-koreatown.html>

The generated gnuplot script darkens the map a bit to make the extra stuff stand
out (C<attenuation> parameter in the resulting script).

Gnuplot assumes a linear mapping between pixels in the gnuplot window and
latitude/longitude, even though this isn't strictly true in the tiles we
download: the longitude I<is> linear but the latitude is not. The script assumes
that we're looking at a small-enough range of latitudes such that the mapping is
linear enough. It fits a line to samples of the nonlinear curve, and uses this
line when making the plot.

The communication with the OSM tile server assumes some caching. If an
appropriately-named tile already exists on disk, the C<If-None-Match> header
field is used to send over the MD5 hash of the tile on disk. If the tile on the
server has the same hash, the server doesn't bother sending it over, which
results in bandwidth savings.

=head1 REQUIRED ARGUMENTS

=over

=item --center <lat>,<lon>

Center point

=for Euclid:
  lat.type: number
  lon.type: number

=item --rad <radius>

How far around the center to query. This must include units (support C<m>, C<km>
and C<miles>; no whitespace between the number and units).

=for Euclid:
  radius.type: /[0-9]+(?:\.[-9]*)?(?:miles?|km|m)/

=item --zoom <zoom>

The OSM zoom level

=for Euclid:
  zoom.type: integer, zoom > 0 && zoom <= 18

=for Euclid:
  radius.type: /[0-9]+(?:\.[-9]*)?(?:miles?|km|m)/

=back

=head1 DEPENDENCIES

I use non-core perl modules C<Getopt::Euclid>, C<LWP::UserAgent> and C<PDL>. I
also use the C<montage> tool from C<imagemagick>. On a Debian box the following
should be sufficient:

 apt-get install libgetopt-euclid-perl libwww-perl pdl imagemagick

=head1 REPOSITORY

L<https://github.com/dkogan/osmgnuplot>

=head1 AUTHOR

Dima Kogan, C<< <dima@secretsauce.net> >>

=head1 LICENSE AND COPYRIGHT

Copyright 2015 Dima Kogan.

This program is free software; you can redistribute it and/or modify it under
the terms of the Lesser General Public License version 3, as published by the
Free Software Foundation. Full text at http://www.gnu.org/licenses/lgpl.html
