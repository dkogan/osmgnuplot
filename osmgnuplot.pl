#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Euclid qw(:defer);
use feature ':5.10';

use Geo::OSM::Tiles qw( :all );
use LWP::UserAgent;
use Digest::MD5 qw(md5);
use PDL;
use PDL::Fit::Linfit;

my @ARGV_original = @ARGV;
my @thiscmd_tokens = split('/',$0);
my $thiscmd =  $thiscmd_tokens[-1];
Getopt::Euclid->process_args(\@ARGV);



my $pi = 3.14159265359;


my $userAgent = LWP::UserAgent->new;




my $center_lat = $ARGV{'--center'}{lat};
my $center_lon = $ARGV{'--center'}{lon};
my $zoom       = $ARGV{'--zoom'};

# I want radius in meters
my ($rad,$unit) = $ARGV{'--rad'} =~ /([0-9\.]+)(.*?)$/;
if   ($unit =~ /mile/) { $rad *= 5280 * 12 * 2.54 / 100; }
elsif($unit =~ /km/ )  { $rad *= 1000; }

my $Rearth = 6371000.0; # meters


my @lat = ($center_lat - $rad/$Rearth * 180.0/$pi,
           $center_lat + $rad/$Rearth * 180.0/$pi );

my @lon = ($center_lon - $rad/$Rearth * 180.0/$pi / cos($center_lat * $pi/180.0),
           $center_lon + $rad/$Rearth * 180.0/$pi / cos($center_lat * $pi/180.0) );

my @tilex = map { lon2tilex($_, $zoom ) } @lon;
my @tiley = map { lat2tiley($_, $zoom ) } @lat;

my @montage_tile_list;
for my $y ($tiley[1]..$tiley[0]) # vertical tiles are ordered backwards because
                                 # that's how the mapping function works
{
    for my $x ($tilex[0]..$tilex[1])
    {
        my $path = tile2path($x, $y, $zoom);
        my $tileurl = "http://tile.openstreetmap.org/$path";
        my $filename = "tile_${x}_${y}_${zoom}.png";


        my @get_args = (":content_file" => $filename);

        if( !$ARGV{'--nocache'} && -r $filename )
        {
            # a local file exists AND we weren't asked to ignore local caches

            # compute the checksum of the local file
            local  $/ = undef;
            open TILE, $filename;
            my $md5_cache = join('', unpack('H*', md5(<TILE>)));
            close TILE;

            # tells server to only send data if needed
            push @get_args, ('if-none-match' => "\"$md5_cache\"" );
        }

        say STDERR "Downloading $tileurl";
        $userAgent->get($tileurl, @get_args)
          or die "Error downloading '$tileurl'";

        push @montage_tile_list, $filename;
    }
}

my $Ntiles_width  = $tilex[1] - $tilex[0] + 1;
my $Ntiles_height = $tiley[1] - $tiley[0] + 1;

my $montage_filename = "montage_${center_lat}_${center_lon}_$ARGV{'--rad'}_$zoom.png";
system("montage @montage_tile_list -tile ${Ntiles_width}x${Ntiles_height} -geometry +0+0 $montage_filename") == 0
  or die "Error running montage: $@";



# I now generate a gnuplot scrript. Here I require dx,dy,centerx,centery to
# properly scale, position the montage

# derived from the source of Geo::OSM::Tiles
my $dx = 360 * 2**(-$zoom) / 256;
my $centerx = ($tilex[0]*256 + $tilex[1]*256 + 255) / 2;
$centerx = $centerx/256 * 2**(-$zoom) * 360 - 180;

# sources of Geo::OSM::Tiles say that
sub tile_from_lat
{
    # input is in degrees, relative to $lat[0]
    # output is floating-point tile index
    #
    # This is done to keep the x variables near 0 to make the slope estimate
    # accurate

    my $lat_here = shift;

    $lat_here += $lat[0];
    $lat_here *= $pi/180.0;

    return (1 - log(tan($lat_here) + 1.0/cos($lat_here))/$pi)/2 * 2**$zoom;
}
# This is (clearly) non-linear, but for small spans of latitude should be linear
# enough. I sample this function through my range, apply linear least squares to
# fit a line to it, and get dy and centery from this line
my $lat_fit = zeros(10)->xlinvals(0, $lat[1]-$lat[0]);
my $tile_fit= pdl( map { tile_from_lat($_) } $lat_fit->list );
my ($fit, $coeffs) = linfit1d($lat_fit, $tile_fit, PDL::cat( $lat_fit->ones,
                                                             $lat_fit));
my @c = $coeffs->list;

# I now have tile ~ $c[0] + (lat - $lat[0])*$c[1];

my $centery = ($tiley[0] + $tiley[1] + 255/256) / 2; # tile
$centery = ($centery - $c[0]) / $c[1] + $lat[0];

# c1 is tiles/deg. I want dy = (1/c1) (deg/tiles) / 256 (px/tile)
my $dy = -1/($c[1]*256); # negative because gnuplot inverts y by
                         # default, so the negative slope this thing has
                         # is not needed



my $gnuplot_script = <<EOF;
# Generated by osmgnuplot.pl from
#   http://notes.secretsauce.net/notes/2015/08/13_rendering-openstreetmap-tiles-in-gnuplot.html
#
# Command used:
#   $thiscmd @ARGV_original

attenuation = 1.5

set autoscale noextend

set size ratio -1./cos($center_lat * pi/180.0)
plot "$montage_filename" binary filetype=png dx=$dx dy=$dy center=($centerx,$centery) using (\$1/attenuation):(\$2/attenuation):(\$3/attenuation) with rgbimage notitle
EOF

my $gpfilename = $montage_filename;
$gpfilename =~ s/png$/gp/;

open GP, '>', $gpfilename;
print GP $gnuplot_script;
close GP;

say "Done! Gnuplot script '$gpfilename' uses the image '$montage_filename'";



__END__

=head1 NAME

osmgnuplot.pl - Download OSM tiles, and make a gnuplot script to render them

=head1 SYNOPSIS

 $ osmgnuplot.pl --center 34.12,-118.34 --radius 20miles --zoom 16

=head1 DESCRIPTION

This script downloads OSM tiles and generates a gnuplot script to render them.
While this in itself is not useful, the gnuplot script can be expanded to plot
other things on top of the map, to make it easy to visualize geospatial data.

This script tries to detect already-downloaded tiles by computing a checksum of
a candidate cache local file, and comparing to what the server tells us in a
header. This can be turned off with --nocache

=head1 REQUIRED ARGUMENTS

=over

=item --center <lat>,<lon>

Center point

=for Euclid:
  lat.type: number
  lon.type: number

=item --rad <radius>

How far around the center to query. This must include units (no whitespace
between number and units).

=for Euclid:
  radius.type: /[0-9]+(?:\.[-9]*)?(?:miles?|km|m)/

=item --zoom <zoom>

The OSM zoom level

=for Euclid:
  zoom.type: integer, zoom > 0 && zoom <= 18

=for Euclid:
  radius.type: /[0-9]+(?:\.[-9]*)?(?:miles?|km|m)/

=back

=head1 OPTIONAL ARGUMENTS

=over

=item --nocache

By default we don't download tiles we have already (based on a checksum). With
this option, we suppress this logic and always download fresh tiles.

=back

=head1 AUTHOR

Dima Kogan, C<< <dima@secretsauce.net> >>
